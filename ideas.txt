structs are anologous to C structs. packing and allignment included

for packed and alligned structs use syntax like struct(packed, allign(4)) { ... }
    this way keywords are conditional

classes are allowed to reorganize members for proper packing

long cast with :: for statements like a = int:: b + c
    or maybe just have a cast assign a := b + c

tuples, being basically dynamically allocated structs

foreach
find something in arrays
sorting
libraries

maybe have a dynamic cast operator? maybe ::
eg MyClass:: value
maybe if needed, can have a reinterpret cast as :::
int::: myfloat

have various different types of import statements. eg: import(string), import(file) or import(include)
have the return value be determined by the import type.

have a 'wlx' utility that will transform the source. eg. transform to-from extensions.

infix casting for chained dot expressions. example: MyClass. MyOtherClass: member.function()

null coelescing operator

ASM can have a syntax similar to other functions: 
asm [ax, bx] somefunc(rax, eax, al)
{
    addl %1 %0
    xorl %%eax %%eax
}


eschew 'default' keyword. 'default' should be whatever content comes before
the  first explicit case:

switch(myValue)
{
    print("ERROR, invalid value")
    case 1
        print("I Have one argument")
    case 2
        print("I Have one argument")
}

if myValue is '3', then 'ERROR' will be printed

